---
title: 数据结构与算法
tags: 学习记录
---

> 卷，卷就完事儿了。
> 用JavaScript写一遍。

## 目录
- 线性结构
- 哈希表
- 树结构
- 图结构
- 排序与搜索

## 数组的回顾与补充
首先，JavaScript中数组的相关知识回顾[见此](https://www.jianshu.com/p/9521594710d7)。

- 常见语言的数组不能存放**不同的数据类型**，因此封装时通常存放在数组中的是Object类型
- 常见语言的数组容量不会自动改变（需要进行扩容，申请一个更大的数组，并复制）
- 常见语言的数据进行**插入**和**删除**的性能较低

> 以上不包含JavaScript

## 栈（Stack）

### 基本了解
- **后进先出**（LIFO）
- 栈顶、栈底，仅允许在栈顶一端进行插入和删除运算
- 插入新元素：进栈、入栈、压栈
- 删除栈元素：出栈、退栈
###  面试题
![图片1.png](https://i.loli.net/2021/08/28/SlwzhagK8GLs67p.png)

> A.6进栈->5进栈->5出栈->4进栈->4出栈->3进栈->3出栈->6出栈->2进栈->1进栈->1出栈->2出栈
> B.6进栈->5进栈->4进栈->4出栈->5出栈->3进栈->3出栈->2进栈->2出栈->1进栈->1出栈->6出栈
> C.6进栈->5进栈->4进栈->3进栈->3出栈->4出栈->？
> D.6进栈->5进栈->4进栈->3进栈->2进栈->2出栈->3出栈->4出栈->1进栈->1出栈->5出栈->6出栈

### 栈的实现
```javascript
// 两种实现方式——数组和链表（JavaScript没有自带链表结构），因此这里的栈结构基于数组实现

// 封装栈类
function Stack() {
    // 栈中的属性
    this.items = []

    // 对于栈的相关操作


    // 将元素压入栈
    Stack.prototype.push = function (element) {
        this.items.push(element)
    }

    // 取出栈顶元素
    Stack.prototype.pop = function () {
        this.items.pop()
    }

    // 查看栈顶元素
    Stack.prototype.peek = function () {
        return this.items[this.items.length - 1]
    }

    // 判断是否为空栈
    Stack.prototype.isEmpty = function () {
        return this.items.length === 0
    }


    // 获取栈中元素个数
    Stack.prototype.size = function () {
        return this.items.length
    }

    // toString
    Stack.prototype.toString = function () {
        var str = ''
        for (let i = 0; i < this.items.length; i++) {
            str += this.items[i] + ' '
        }
        return str
    }
}

// 栈的使用
var s = new Stack()

s.push(20)
s.push(10)
s.push(25)
s.push(66)
s.push(22)

console.log(s)
s.pop()
console.log(s)
console.log(s.peek())
console.log(s.isEmpty())
console.log(s.size())
console.log(s.toString())
```

### 栈的应用——十进制转换为二进制
```javascript
// 十进制转为二进制
function dec2bin(decNumber){
    var stack = new Stack()
    while(decNumber > 0)
    {
        // 获取余数，放入栈中
        stack.push(decNumber%2)

        // 获取整除后的结果作为下一次运算的数字 floor 向下取整
        decNumber = Math.floor(decNumber / 2)

    }
    var binNumber = ''
    while(!stack.isEmpty())
    {
        binNumber += stack.pop()
    }
    return binNumber
}

console.log(dec2bin(100))
```

## 队列（Queue）

### 基本了解
- 先进先出（FIFO）
- 只允许在**前端**（front）删除，在**后端**（rear）进行插入
- 可以理解为生活中的排队
- 应用：打印队列、线程队列

### 队列的代码实现
```javascript
// 实现方式：基于数组、基于链表

// 首先选择基于数组
function Queue(){
    // 属性
    this.items = []

    // 方法
    // enqueue 进入列队
    Queue.prototype.enqueue = function (element){
        this.items.push(element)
    }

    // dequeue 移除第一项，返回被移除的元素
    Queue.prototype.dequeue = function(){
        let frontElement = this.items[0]
        // shift方法可以删除第一个元素
        this.items.shift()
        return frontElement
    }

    // front 返回第一个元素
    Queue.prototype.front = function(){
        return this.items[0]
    }
    // isEmpty
    Queue.prototype.isEmpty = function(){
        return this.items.length === 0
    }
    // size
    Queue.prototype.size = function(){
        return this.items.length
    }
    // toString
    Queue.prototype.toString = function () {
        let str = ''
        for (let i = 0; i < this.items.length; i++) {
            str += this.items[i] + ' '
        }
        return str
    }
}

var queue = new Queue()

queue.enqueue('abc')
queue.enqueue('hitsz')
queue.enqueue('hbshgzx')
queue.enqueue('frontend')

console.log(queue)

queue.dequeue()

console.log(queue)

console.log(queue.front())

console.log(queue.isEmpty())

console.log(queue.size())

console.log(queue.toString())

console.log(typeof queue.toString())
```

### 击鼓传花
- 几个人围成一圈数数，规定数到某个数字的人退出
- 注意画图加强理解
- 比如数到这个人出去，是从这个人的下一个人开始重新计数，并不是从最前面的那个人开始重新计数（刚开始犯了这个错误，一直没得到正确答案）

![QQ图片20210828155149.jpg](https://i.loli.net/2021/08/28/zLZqh6WNRi8T5Px.jpg)
- 把这个问题弄明白以后终于知道为什么队列里要重新把第一个人取出，然后再插入到最后一个了

```javascript
// 击鼓传花
function passParcel(name, number) {
    let nameQueue = new Queue()

    // 所有人加到队列中
    for (let i = 0; i < name.length; i++) {
        nameQueue.enqueue(name[i])
    }

    // 开始数数，数到对应数字淘汰
    // 如果数的不是这个数字，重新加到队列末尾
    // 是这个数字 淘汰
    while (nameQueue.size() > 1) {
        for (let i = 0; i < number - 1; i++) {
            // number之前的人，重新加入队尾
            nameQueue.enqueue(nameQueue.dequeue())
            console.log(nameQueue)
        }
        // 淘汰掉number对应的那个人
        console.log(nameQueue.dequeue())
    }

    return nameQueue.front()

}

console.log(passParcel([1,2,3,4,5],6)) // 4
```
### 优先级队列
- 优先级队列中，插入元素时会考虑元素的优先级
- 其他处理方式和普通队列一样
- 每个元素不再只是一个数据，而是包括数据的优先级（**数据**和**数据的优先级**）

- 生活例子，头等舱、经济舱登机顺序等
- 计算机例子，线程任务的重要性不同，因此优先级也不同

主要是插入元素时，需要根据优先级，确定插入元素的位置，插入数据时，如果队列为空，则必然插到队首，否则遍历队列，直到找到优先级比我们的数组要高的位置，在其前面插入，如果直到最后也没有找到位置，则在队尾插入数据

## 链表（LinkedList）
### 数组（列表）和链表
- 数组（列表）有很多缺点，需要连续的内存空间（一整块内存），大小固定（大多数语言，如C语言），容量不满足需求时，需要进行扩容（一般情况下是申请一个更大的数组，然后将原数组中的元素复制进去）
- 在数组开头或中间位置插入元素，成本较高，需要大量元素的位移
- JavaScript中，对于数组进行操作的Array类方法，原理都是如此

- 链表在内存中不必是连续的空间，每个元素由**元素本身的节点**和**指向下一个元素的引用**（指针、连接）组成

> 链表的优点
> - 内存空间不必连续，可以实现内存动态管理
> - 不必在创建时确定大小，可以无限延伸下去
> - 插入和删除数据时，**时间复杂度可以达到O(1)**，效率高
> 
> 链表的缺点
> - 访问任何位置的元素都需要从头开始
> - 无法通过下标访问元素，需要从头开始一个个找到对应元素

### 链表结构的封装

<!--more--> 

---

2021年8月28日

